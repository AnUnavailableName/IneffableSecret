# Linux学习

<center>2023年9月4日</center>

## 1. Linux内核体系结构

* 操作系统组成（完整可用）
> 硬件系统、操作系统内核、操作系统服务、用户应用程序。

* 内核模式
> 单内核模式、层次的微内核模式。单内核结构紧凑，执行快；但层次结构性不强。Linux 0.11内核采用单内核。

* 单内核系统，操作系统提供服务的流程
> 应用程序调用系统指令-cpu切换到内核态-系统根据参数调用特定的系统服务程序-调用底层函数完成功能-切回用户态-返回应用程序继续执行。总体结构是用户程序-系统服务-底层函数。

* 内核的构成模块
> 进程调度、内存管理、文件系统、进程间通讯、网络接口。

* 什么是内存管理模块的虚拟内存管理方式
> 1. 虚拟内存的关键点：每个进程对应自己独立的虚拟地址空间，进程访问的这个空间并不是真正的物理地址；虚拟地址通过每个进程上页表与物理地址进行映射从而访问真正的物理地址；假如缺页，则分配地址并更新页表，假如此时物理内存耗尽则**根据内存替换算法淘汰部分页面到物理磁盘。** 
> 2. Linux虚拟内存空间分配：只读段（程序）-读写段（全局/静态变量）-堆-栈-内核虚拟空间（用户代码不可见）。32位系统有4G的地址空间，其中0X08048000~0Xbfffffff是用户空间，0Xc0000000~0Xffffffff是内核空间，包含内核代码和数据、与进程相关的数据结构（如页表，内核栈）等。另外%esp执行栈顶，往低地址方向变化；brk/sbrk函数控制堆顶往高地址方向变化。
> 3. malloc分配内存时，若分配内存小于128k，调用sbrk()将堆顶指针向高地址移动获取新虚拟地址。若分配内存大于128k，调用mmap()，在文件映射区域分配匿名虚拟空间。malloc分配的是虚拟地址空间，使用ps-aux命令查看内存使用情况，可以看到**进程实际使用的物理空间大小RSS总小于进程总共使用的虚拟地址空间大小VSZ**。
> 4. VSZ并不是每次malloc后都增长，是与上一节说的堆顶没发生变化有关，因为**可重用堆顶内剩余的空间**，这样malloc是很轻量和快速的;如果**VSZ发生变化，基本与分配内存量相当**，因为VSZ是计算虚拟地址空间总大小;**malloc分配的内存并不就马上分配实际的存储空间**，只有第一次使用后才分配；**由于每个物理页面大小是4K，不管memset其中的1K，还是5K，7K，实际占用物理内存总是4K的倍数。所以RSS的增量总是4K的倍数；** **第一次使用时发现虚存对应的物理页面未分配，产生缺页中断，才真正分配物理页面，同时更新进程页表的映射关系。这也是Linux虚拟内存管理的核心概念之一。**
> **[总结]虚拟内存的精髓就在于，通过增加页表这一映射层，实现在内存不够用的情况下再分配实际的物理内存。**

<center>2023年9月5日</center>

* linux文件系统中swap区的作用
> Windows系统中对于长时间未操作的程序的内存数据处理，是将该程序创建一个独享的交换文件，把内存中的数据存储到文件系统里，释放内存空间供其他程序使用；当再次操作的时候，系统再从文件系统中恢复数据到内存，继续运行，因此每个程序都至少打开一个文件进行读写。对于Linux系统而言，使用malloc和new申请的空间生成的对象没有独立空间可以交换内存数据，因此创建了swap这一匿名内存数据交换空间，将所有长期未运行的程序内存暂存，释放内存空间提供给其他程序。

* Linux的定时实现
> 主芯外部的定时芯片定时产生（10ms）一个时钟中断信号，运行do_timer()函数。做虚拟定时器的时基。[推测]所有的进程的分时运行机制都与虚拟定时器有关，因为这似乎涉及到进程控制和中断控制的问题了。内核态禁止被抢占。

* [问题]
“Linux系统中，一个进程可以在内核态(kernel mode)或用户态(user mode)下执行”。――P26
“在单内核模式的系统中，操作系统所提供服务的流程为:应用主程序使用指定的参数值执行系统调用指令(int x80)，使 CPU 从用户态(User Mode) 切换到核心态(Kernel Model)，然后操作系统根据具体的参数值调用特定的系统调用服务程序”。――P21
这两段的矛盾点在于，**内核态与用户态的切换以何为依据？是与用户/系统调用深度绑定，还是作为进程的一种可选的运行权限？**

